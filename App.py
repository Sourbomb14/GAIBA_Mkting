import streamlit as st
import pandas as pd
import numpy as np
import smtplib
import ssl
import time
import re
import json
import plotly.express as px
import plotly.graph_objects as go
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email_validator import validate_email, EmailNotValidError
from dotenv import load_dotenv
import os
from datetime import datetime, timedelta
import io
import base64
from groq import Groq
from google import genai
from PIL import Image
import requests

# Load environment variables
load_dotenv()

# Configuration
GROQ_API_KEY = os.getenv("GROQ_API_KEY")
GMAIL_USER = os.getenv("GMAIL_USER")
GMAIL_APP_PASSWORD = os.getenv("GMAIL_APP_PASSWORD")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

# Countries data with coordinates
COUNTRIES_DATA = {
    "Global": {"coords": [0, 0], "currency": "USD"},
    "United States": {"coords": [39.8283, -98.5795], "currency": "USD"},
    "Canada": {"coords": [56.1304, -106.3468], "currency": "CAD"},
    "United Kingdom": {"coords": [55.3781, -3.4360], "currency": "GBP"},
    "Germany": {"coords": [51.1657, 10.4515], "currency": "EUR"},
    "France": {"coords": [46.6034, 1.8883], "currency": "EUR"},
    "Spain": {"coords": [40.4637, -3.7492], "currency": "EUR"},
    "Italy": {"coords": [41.8719, 12.5674], "currency": "EUR"},
    "Netherlands": {"coords": [52.1326, 5.2913], "currency": "EUR"},
    "Australia": {"coords": [-25.2744, 133.7751], "currency": "AUD"},
    "Japan": {"coords": [36.2048, 138.2529], "currency": "JPY"},
    "India": {"coords": [20.5937, 78.9629], "currency": "INR"},
    "China": {"coords": [35.8617, 104.1954], "currency": "CNY"},
    "Brazil": {"coords": [-14.2350, -51.9253], "currency": "BRL"},
    "Mexico": {"coords": [23.6345, -102.5528], "currency": "MXN"}
}

COUNTRIES = list(COUNTRIES_DATA.keys())
CURRENCIES = ["USD", "EUR", "GBP", "CAD", "AUD", "JPY", "CHF", "INR", "BRL", "MXN", "CNY"]

# ================================
# SESSION STATE INITIALIZATION
# ================================

def initialize_session_state():
    """Initialize all session state variables"""
    if 'current_page' not in st.session_state:
        st.session_state.current_page = "Campaign Dashboard"
    if 'current_campaign' not in st.session_state:
        st.session_state.current_campaign = None
    if 'campaign_blueprint' not in st.session_state:
        st.session_state.campaign_blueprint = None
    if 'email_template' not in st.session_state:
        st.session_state.email_template = None
    if 'email_contacts' not in st.session_state:
        st.session_state.email_contacts = None
    if 'campaign_results' not in st.session_state:
        st.session_state.campaign_results = None
    if 'plain_text_template' not in st.session_state:
        st.session_state.plain_text_template = None
    if 'generated_images' not in st.session_state:
        st.session_state.generated_images = []
    if 'email_sending' not in st.session_state:
        st.session_state.email_sending = False

# ================================
# FIXED GEMINI IMAGE GENERATOR
# ================================

class GeminiImageGenerator:
    """Generate images using Gemini AI with proper implementation"""
    
    def __init__(self):
        self.client = None
        if GEMINI_API_KEY:
            try:
                self.client = genai.Client(api_key=GEMINI_API_KEY)
            except Exception as e:
                st.error(f"Failed to initialize Gemini: {e}")
    
    def generate_campaign_image(self, campaign_description, style="professional"):
        """Generate campaign image using Gemini"""
        if not GEMINI_API_KEY:
            st.warning("‚ö†Ô∏è Gemini API key not configured. Please add GEMINI_API_KEY to your .env file")
            return None
            
        if not self.client:
            st.error("‚ùå Gemini client not initialized")
            return None
            
        try:
            prompt = f"Professional marketing campaign image for: {campaign_description}, style: {style}. Create a high-quality, engaging marketing visual with modern design elements, brand colors, and compelling imagery suitable for digital marketing campaigns."
            
            with st.spinner("üé® Generating campaign image with Gemini AI..."):
                result = self.client.models.generate_images(
                    model="models/imagen-4.0-generate-001",
                    prompt=prompt,
                    config=dict(
                        number_of_images=1,
                        output_mime_type="image/jpeg",
                        person_generation="ALLOW_ALL",
                        aspect_ratio="16:9",
                        image_size="1K",
                    ),
                )
                
                if not result.generated_images:
                    st.error("‚ùå No images generated by Gemini")
                    return None
                
                # Save and display the generated image
                generated_image = result.generated_images[0]
                
                # Save to session state
                image_data = {
                    'prompt': prompt,
                    'timestamp': datetime.now(),
                    'campaign': campaign_description,
                    'image': generated_image.image
                }
                
                st.session_state.generated_images.append(image_data)
                
                # Display the image
                st.success("‚ú® Campaign image generated successfully!")
                st.image(generated_image.image, caption=f"Generated for: {campaign_description}", use_column_width=True)
                
                # Provide download option
                img_bytes = io.BytesIO()
                generated_image.image.save(img_bytes, format='JPEG')
                img_bytes.seek(0)
                
                st.download_button(
                    "üì• Download Campaign Image",
                    data=img_bytes.getvalue(),
                    file_name=f"campaign_image_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg",
                    mime="image/jpeg"
                )
                
                return generated_image.image
            
        except Exception as e:
            st.error(f"‚ùå Error generating image with Gemini: {str(e)}")
            st.info("üí° Make sure your Gemini API key is valid and has image generation permissions")
            return None

# ================================
# FIXED GROQ INTEGRATION
# ================================

class GroqAIGenerator:
    """Generate content using Groq AI with your specified model"""
    
    def __init__(self):
        self.client = None
        if GROQ_API_KEY:
            try:
                self.client = Groq(api_key=GROQ_API_KEY)
            except Exception as e:
                st.error(f"Failed to initialize Groq: {e}")
    
    def generate_campaign_blueprint(self, campaign_data):
        """Generate campaign blueprint using Groq with your specified model"""
        if not self.client:
            return self._fallback_blueprint(campaign_data)
        
        try:
            prompt = self._build_campaign_prompt(campaign_data)
            
            # Using your specified model and parameters
            completion = self.client.chat.completions.create(
                model="openai/gpt-oss-20b",
                messages=[
                    {
                        "role": "system",
                        "content": "You are a world-class marketing strategist with 20+ years of experience. Create comprehensive, actionable marketing campaign strategies that drive real business results."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.7,
                max_completion_tokens=8192,
                top_p=1,
                reasoning_effort="medium",
                stream=True,
                stop=None
            )
            
            # Collect streamed response
            full_response = ""
            for chunk in completion:
                if chunk.choices[0].delta.content:
                    full_response += chunk.choices[0].delta.content
            
            return full_response
            
        except Exception as e:
            st.error(f"Error with Groq API: {e}")
            return self._fallback_blueprint(campaign_data)
    
    def generate_personalized_email_content(self, campaign_data, email_type, tone, content_format):
        """Generate personalized email content using Groq"""
        if not self.client:
            return self._fallback_email_content(content_format)
        
        try:
            prompt = self._build_email_prompt(campaign_data, email_type, tone, content_format)
            
            completion = self.client.chat.completions.create(
                model="openai/gpt-oss-20b",
                messages=[
                    {
                        "role": "system",
                        "content": "You are an expert email marketing specialist. Create high-converting, personalized email content that drives engagement and action."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.6,
                max_completion_tokens=4096,
                top_p=1,
                reasoning_effort="medium",
                stream=True,
                stop=None
            )
            
            # Collect streamed response
            full_response = ""
            for chunk in completion:
                if chunk.choices[0].delta.content:
                    full_response += chunk.choices[0].delta.content
            
            return full_response
            
        except Exception as e:
            st.error(f"Error generating email content: {e}")
            return self._fallback_email_content(content_format)
    
    def _build_campaign_prompt(self, data):
        """Build comprehensive campaign prompt"""
        return f"""
        Create a comprehensive and highly detailed marketing campaign blueprint for the following:
        
        **CAMPAIGN SPECIFICATIONS:**
        - Company: {data.get('company_name', 'Company')}
        - Campaign Type: {data.get('campaign_type', 'Marketing')}
        - Target Audience: {data.get('target_audience', 'General')}
        - Geographic Target: {data.get('location', 'Global')} {data.get('city_state', '')}
        - Marketing Channels: {', '.join(data.get('channels', []))}
        - Budget: {data.get('budget', 'TBD')} {data.get('currency', 'USD')}
        - Campaign Duration: {data.get('duration', 'TBD')}
        - Product/Service: {data.get('product_description', 'Product/Service')}
        - Customer Segment: {data.get('customer_segment', 'General')}
        
        **REQUIRED DELIVERABLES:**
        
        1. **EXECUTIVE SUMMARY** (2-3 paragraphs)
           - Campaign overview and key objectives
           - Expected outcomes and success metrics
        
        2. **TARGET AUDIENCE ANALYSIS**
           - Detailed demographic and psychographic profile
           - Pain points and motivations
           - Customer journey mapping
           - Preferred communication channels
        
        3. **COMPETITIVE LANDSCAPE**
           - Market positioning analysis
           - Competitive advantages
           - Differentiation strategy
        
        4. **KEY MESSAGING FRAMEWORK**
           - Primary value proposition
           - Supporting messages for each audience segment
           - Emotional triggers and rational benefits
           - Brand voice and tone guidelines
        
        5. **CHANNEL-SPECIFIC STRATEGY**
           - Detailed tactics for each selected channel: {', '.join(data.get('channels', []))}
           - Content formats and posting frequency
           - Budget allocation per channel
           - Performance benchmarks
        
        6. **CAMPAIGN TIMELINE & EXECUTION PLAN**
           - Phase 1: Pre-launch (preparation tasks)
           - Phase 2: Launch (go-to-market execution)
           - Phase 3: Optimization (performance improvement)
           - Phase 4: Scale & Sustain
        
        7. **BUDGET BREAKDOWN & ROI PROJECTIONS**
           - Detailed cost allocation in {data.get('currency', 'USD')}
           - Expected ROI and ROAS calculations
           - Cost per acquisition estimates
        
        8. **SUCCESS METRICS & KPIs**
           - Primary success indicators
           - Secondary performance metrics
           - Tracking and measurement methodology
        
        9. **RISK ASSESSMENT & MITIGATION**
           - Potential challenges and obstacles
           - Contingency plans and alternative strategies
           - Quality assurance checkpoints
        
        10. **IMPLEMENTATION ROADMAP**
            - Step-by-step action items
            - Resource requirements and team roles
            - Critical milestones and deadlines
        
        Make this blueprint highly actionable, data-driven, and tailored specifically for {data.get('location', 'the target market')}. Include specific recommendations that can be implemented immediately.
        """
    
    def _build_email_prompt(self, campaign_data, email_type, tone, content_format):
        """Build email content prompt"""
        company = campaign_data.get('company_name', 'Our Company') if campaign_data else 'Our Company'
        campaign_type = campaign_data.get('campaign_type', 'marketing campaign') if campaign_data else 'marketing campaign'
        audience = campaign_data.get('target_audience', 'valued customers') if campaign_data else 'valued customers'
        
        format_instruction = "HTML email template with inline CSS" if content_format == "HTML Template" else "plain text email"
        
        return f"""
        Create a high-converting {format_instruction} for {company}'s {campaign_type}.
        
        **EMAIL SPECIFICATIONS:**
        - Email Type: {email_type}
        - Tone: {tone}
        - Target Audience: {audience}
        - Format: {format_instruction}
        
        **REQUIREMENTS:**
        - Include compelling subject line suggestions (3 options)
        - Use personalization placeholders: {{{{first_name}}}}, {{{{name}}}}, {{{{email}}}}
        - Create engaging opening that hooks the reader
        - Clear value proposition and benefits
        - Strong call-to-action (CTA) button/link
        - Professional closing and signature
        - Mobile-responsive design (if HTML)
        - Compliance with email marketing best practices
        
        **CONTENT STRUCTURE:**
        1. Subject Line Options (3 variations)
        2. Email Content (complete template)
        3. Alternative CTA suggestions
        
        {"For HTML: Use inline CSS, ensure cross-client compatibility, include fallback fonts. Create visually appealing layout with proper spacing, colors, and typography." if content_format == "HTML Template" else "For Plain Text: Use clear formatting with line breaks, bullet points, and proper spacing for easy readability."}
        
        Make this email highly engaging, conversion-focused, and perfectly tailored for {audience}.
        """
    
    def _fallback_blueprint(self, data):
        """Fallback blueprint if API fails"""
        return f"""
# {data.get('company_name', 'Your Company')} - {data.get('campaign_type', 'Marketing')} Campaign

## Executive Summary
Comprehensive {data.get('campaign_type', 'marketing')} campaign targeting {data.get('target_audience', 'key audience')} in {data.get('location', 'target market')}.

## Campaign Objectives
- Increase brand awareness and market penetration
- Drive qualified lead generation
- Boost customer engagement and conversions
- Achieve measurable ROI within campaign period

## Target Audience Analysis
**Primary Target:** {data.get('target_audience', 'Target Audience')}
- Geographic Focus: {data.get('location', 'Market Location')}
- Customer Segment: {data.get('customer_segment', 'Market Segment')}
- Preferred Channels: {', '.join(data.get('channels', ['Digital Channels']))}

## Channel Strategy
**Selected Channels:** {', '.join(data.get('channels', ['Email', 'Social Media']))}
- Integrated approach across all touchpoints
- Channel-specific content optimization
- Cross-channel attribution tracking

## Implementation Timeline
- **Phase 1:** Campaign setup and preparation
- **Phase 2:** Launch and initial optimization
- **Phase 3:** Scale and performance improvement
- **Phase 4:** Analysis and future planning

## Budget & ROI
- **Total Budget:** {data.get('budget', 'TBD')} {data.get('currency', 'USD')}
- **Expected ROI:** 250-400%
- **Timeline:** {data.get('duration', 'Campaign Duration')}

## Success Metrics
- Reach and impressions
- Engagement rates
- Conversion rates
- Customer acquisition cost
- Return on advertising spend
"""
    
    def _fallback_email_content(self, content_format):
        """Fallback email content"""
        if content_format == "HTML Template":
            return '''
<!DOCTYPE html>
<html>
<head>
    <title>Campaign Email</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 0; background-color: #f5f5f5; }
        .email-container { background-color: #ffffff; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px 20px; text-align: center; }
        .content { padding: 30px 20px; line-height: 1.6; }
        .cta-button { background: #007bff; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; display: inline-block; margin: 20px 0; font-weight: bold; }
        .footer { background: #f8f9fa; padding: 20px; text-align: center; font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="header">
            <h1>Hello {{first_name}}!</h1>
            <p>We have something special for you</p>
        </div>
        <div class="content">
            <p>We're excited to share this exclusive opportunity with you, {{name}}.</p>
            <p>As a valued member of our community, you get early access to our latest campaign.</p>
            <div style="text-align: center;">
                <a href="#" class="cta-button">Discover More</a>
            </div>
            <p>Thank you for being part of our journey!</p>
        </div>
        <div class="footer">
            <p>Best regards,<br>The Marketing Team</p>
            <p>You received this because you're subscribed to our updates.</p>
        </div>
    </div>
</body>
</html>
'''
        else:
            return '''Subject: Exclusive Opportunity for {{first_name}}

Hello {{first_name}},

We're excited to share this exclusive opportunity with you.

As a valued member of our community, you get early access to our latest campaign.

Here's what makes this special:
‚Ä¢ Personalized just for you
‚Ä¢ Exclusive member benefits  
‚Ä¢ Limited-time access
‚Ä¢ Premium features included

Ready to explore? Visit our website or reply to this email.

Thank you for being part of our journey, {{name}}!

Best regards,
The Marketing Team

---
You received this email because you're subscribed to our updates.
Unsubscribe | Update Preferences'''

# ================================
# EMAIL PERSONALIZER
# ================================

class EmailPersonalizer:
    """Handle intelligent email personalization"""
    
    @staticmethod
    def extract_name_from_email(email):
        """Extract potential name from email address"""
        try:
            local_part = email.split('@')[0]
            name_part = re.sub(r'[0-9._-]', ' ', local_part)
            name_parts = [part.capitalize() for part in name_part.split() if len(part) > 1]
            return ' '.join(name_parts) if name_parts else 'Valued Customer'
        except:
            return 'Valued Customer'
    
    @staticmethod
    def personalize_template(template, name, email=None):
        """Personalize email template"""
        first_name = name.split()[0] if name and ' ' in name else name
        
        personalized = template.replace('{name}', name or 'Valued Customer')
        personalized = personalized.replace('{{name}}', name or 'Valued Customer')
        personalized = personalized.replace('{first_name}', first_name or 'Valued Customer')
        personalized = personalized.replace('{{first_name}}', first_name or 'Valued Customer')
        personalized = personalized.replace('{email}', email or '')
        personalized = personalized.replace('{{email}}', email or '')
        
        return personalized

# ================================
# FIXED EMAIL HANDLER
# ================================

class EmailHandler:
    """COMPLETELY FIXED email handling with robust error handling"""
    
    def __init__(self):
        self.smtp_server = "smtp.gmail.com"
        self.smtp_port = 587
        self.email = GMAIL_USER
        self.password = GMAIL_APP_PASSWORD
    
    def validate_email_address(self, email):
        try:
            validate_email(email)
            return True
        except EmailNotValidError:
            return False
    
    def send_single_email(self, to_email, subject, body, is_html=True):
        """Send a single email with comprehensive error handling"""
        if not self.email or not self.password:
            return False, "Gmail credentials not configured. Please check GMAIL_USER and GMAIL_APP_PASSWORD in .env file"
            
        try:
            msg = MIMEMultipart('alternative')
            msg['From'] = self.email
            msg['To'] = to_email
            msg['Subject'] = subject
            
            if is_html:
                msg.attach(MIMEText(body, 'html'))
            else:
                msg.attach(MIMEText(body, 'plain'))
            
            context = ssl.create_default_context()
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls(context=context)
                server.login(self.email, self.password)
                text = msg.as_string()
                server.sendmail(self.email, to_email, text)
            
            return True, "Success"
            
        except smtplib.SMTPAuthenticationError as e:
            return False, f"Gmail authentication failed. Check your app password: {str(e)}"
        except smtplib.SMTPRecipientsRefused as e:
            return False, f"Recipient {to_email} was refused: {str(e)}"
        except smtplib.SMTPServerDisconnected as e:
            return False, f"SMTP server disconnected: {str(e)}"
        except Exception as e:
            return False, f"Email sending error: {str(e)}"
    
    def send_bulk_emails_completely_fixed(self, email_list, subject, body_template, personalizer, is_html=True):
        """COMPLETELY FIXED bulk email sending function"""
        
        # Validate credentials first
        if not self.email or not self.password:
            st.error("‚ùå Gmail configuration missing!")
            st.error("Please ensure GMAIL_USER and GMAIL_APP_PASSWORD are set in your .env file")
            st.code("""
# Add to your .env file:
GMAIL_USER=your_email@gmail.com
GMAIL_APP_PASSWORD=your_16_digit_app_password
            """)
            return pd.DataFrame()
        
        total_emails = len(email_list)
        results = []
        
        # Create persistent containers
        progress_container = st.container()
        status_container = st.container()
        metrics_container = st.container()
        
        sent_count = 0
        failed_count = 0
        invalid_count = 0
        
        # Process each email
        for index, row in email_list.iterrows():
            current_progress = (index + 1) / total_emails
            
            # Update progress
            with progress_container:
                st.progress(current_progress, text=f"Processing {index + 1} of {total_emails}")
            
            # Update status
            with status_container:
                st.info(f"üìß Sending to: {row['email']} ({row.get('name', 'Unknown')})")
            
            # Validate email
            if not self.validate_email_address(row['email']):
                invalid_count += 1
                results.append({
                    "email": row['email'],
                    "name": row.get('name', 'Unknown'),
                    "status": "invalid",
                    "error": "Invalid email format",
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                })
            else:
                # Prepare personalized content
                name = row.get('name', personalizer.extract_name_from_email(row['email']))
                
                try:
                    personalized_body = personalizer.personalize_template(body_template, name, row['email'])
                    personalized_subject = personalizer.personalize_template(subject, name, row['email'])
                    
                    # Send email
                    success, error_msg = self.send_single_email(
                        row['email'], 
                        personalized_subject, 
                        personalized_body, 
                        is_html=is_html
                    )
                    
                    if success:
                        sent_count += 1
                        status = "sent"
                        error_msg = ""
                    else:
                        failed_count += 1
                        status = "failed"
                    
                    results.append({
                        "email": row['email'],
                        "name": name,
                        "status": status,
                        "error": error_msg,
                        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    })
                    
                except Exception as e:
                    failed_count += 1
                    results.append({
                        "email": row['email'],
                        "name": row.get('name', 'Unknown'),
                        "status": "failed",
                        "error": f"Processing error: {str(e)}",
                        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    })
            
            # Update live metrics
            with metrics_container:
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("‚úÖ Sent", sent_count, delta=None)
                with col2:
                    st.metric("‚ùå Failed", failed_count, delta=None)
                with col3:
                    st.metric("‚ö†Ô∏è Invalid", invalid_count, delta=None)
                with col4:
                    st.metric("üìä Progress", f"{current_progress * 100:.1f}%", delta=None)
            
            # Rate limiting delay
            time.sleep(1.5)
        
        # Final status update
        with progress_container:
            st.progress(1.0, text="Campaign completed!")
        
        with status_container:
            st.success("üéâ Email campaign completed successfully!")
        
        return pd.DataFrame(results)

# ================================
# FILE PROCESSOR
# ================================

class FileProcessor:
    """Process files and extract contacts"""
    
    def __init__(self):
        self.email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        self.personalizer = EmailPersonalizer()
    
    def process_file(self, uploaded_file):
        """Process uploaded file and extract contacts"""
        try:
            file_extension = uploaded_file.name.split('.')[-1].lower()
            
            if file_extension == 'csv':
                df = pd.read_csv(uploaded_file)
            elif file_extension in ['xlsx', 'xls']:
                df = pd.read_excel(uploaded_file)
            else:
                st.error("Unsupported file format. Please use CSV or Excel files.")
                return None
            
            return self._process_dataframe(df)
            
        except Exception as e:
            st.error(f"Error processing file: {e}")
            return None
    
    def _process_dataframe(self, df):
        """Process dataframe and standardize columns"""
        # Convert column names to lowercase
        df.columns = df.columns.str.lower()
        
        # Find email and name columns
        email_col = None
        name_cols = []
        
        # Look for email column
        for col in df.columns:
            if 'email' in col or 'mail' in col:
                email_col = col
                break
        
        # Look for name columns
        for col in df.columns:
            if any(keyword in col for keyword in ['name', 'first', 'last', 'fname', 'lname']):
                name_cols.append(col)
        
        if email_col is None:
            st.error("‚ùå No email column found in the file. Please ensure your file has an 'email' column.")
            st.info("üí° Expected column names: 'email', 'mail', 'email_address', etc.")
            return None
        
        # Process contacts
        result_data = []
        
        for _, row in df.iterrows():
            email = row[email_col]
            if pd.isna(email) or str(email).strip() == '':
                continue
            
            # Clean email
            email = str(email).strip().lower()
            
            # Get name
            name_parts = []
            for name_col in name_cols:
                if name_col in row and not pd.isna(row[name_col]):
                    name_parts.append(str(row[name_col]).strip())
            
            if name_parts:
                full_name = ' '.join(name_parts)
            else:
                full_name = self.personalizer.extract_name_from_email(email)
            
            # Validate email
            try:
                validate_email(email)
                result_data.append({'email': email, 'name': full_name})
            except EmailNotValidError:
                continue
        
        if not result_data:
            st.error("‚ùå No valid emails found in the file")
            return None
        
        result_df = pd.DataFrame(result_data)
        st.success(f"‚úÖ Successfully processed {len(result_df)} valid contacts!")
        return result_df

# ================================
# STREAMLIT APP CONFIGURATION
# ================================

st.set_page_config(
    page_title="Marketing Campaign Generator",
    page_icon="üöÄ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Initialize session state
initialize_session_state()

# Custom CSS
st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
    
    .stApp {
        background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
        font-family: 'Inter', sans-serif;
    }
    
    h1, h2, h3 {
        color: #00d4ff !important;
        font-weight: 600 !important;
    }
    
    .stButton > button {
        background: linear-gradient(45deg, #00d4ff, #0099cc) !important;
        color: white !important;
        border: none !important;
        border-radius: 10px !important;
        padding: 0.75rem 1.5rem !important;
        font-weight: 600 !important;
        transition: all 0.3s ease !important;
        box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3) !important;
        width: 100% !important;
    }
    
    .stButton > button:hover {
        transform: translateY(-2px) !important;
        box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4) !important;
    }
    
    .success-button {
        background: linear-gradient(45deg, #28a745, #20c997) !important;
        color: white !important;
    }
    
    .stTextInput > div > div > input,
    .stTextArea > div > div > textarea,
    .stSelectbox > div > div > select {
        background-color: #1e1e1e !important;
        color: #ffffff !important;
        border: 1px solid #333 !important;
        border-radius: 8px !important;
    }
</style>
""", unsafe_allow_html=True)

def main():
    # Header
    st.markdown("""
    <div style="text-align: center; padding: 2rem 0;">
        <h1 style="font-size: 3rem; margin-bottom: 0;">üöÄ Marketing Campaign War Room</h1>
        <p style="font-size: 1.2rem; color: #888; margin-top: 0;">AI-Powered Campaign Generation & Email Marketing Platform</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Navigation
    with st.sidebar:
        st.markdown("### üéØ Navigation")
        
        # Navigation buttons
        if st.button("üéØ Campaign Dashboard", key="nav_campaign"):
            st.session_state.current_page = "Campaign Dashboard"
            st.rerun()
        
        if st.button("üìß Email Marketing", key="nav_email"):
            st.session_state.current_page = "Email Marketing"
            st.rerun()
        
        if st.button("üìä Analytics & Reports", key="nav_analytics"):
            st.session_state.current_page = "Analytics & Reports"
            st.rerun()
        
        st.markdown("---")
        
        # System status
        st.markdown("### üîß System Status")
        
        if GROQ_API_KEY:
            st.success("ü§ñ Groq AI: Connected")
        else:
            st.error("ü§ñ Groq AI: Not configured")
        
        if GMAIL_USER and GMAIL_APP_PASSWORD:
            st.success("üìß Email Service: Connected")
        else:
            st.error("üìß Email Service: Not configured")
        
        if GEMINI_API_KEY:
            st.success("üé® Gemini AI: Connected")
        else:
            st.warning("üé® Gemini AI: Not configured")
        
        st.markdown("---")
        
        # Campaign info
        if st.session_state.current_campaign:
            st.markdown("### üéØ Active Campaign")
            st.info(f"**{st.session_state.current_campaign['company_name']}**")
            st.caption(f"Type: {st.session_state.current_campaign['campaign_type']}")
        
        if st.session_state.email_contacts is not None:
            st.markdown("### üìä Contacts")
            st.info(f"üìß Loaded: {len(st.session_state.email_contacts)}")
    
    # Main content
    if st.session_state.current_page == "Campaign Dashboard":
        show_campaign_dashboard()
    elif st.session_state.current_page == "Email Marketing":
        show_email_marketing()
    elif st.session_state.current_page == "Analytics & Reports":
        show_analytics_reports()

def show_campaign_dashboard():
    st.header("üéØ AI Campaign Strategy Generator")
    
    # Campaign form
    with st.form("campaign_form"):
        col1, col2 = st.columns(2)
        
        with col1:
            company_name = st.text_input("üè¢ Company Name", 
                value=st.session_state.current_campaign['company_name'] if st.session_state.current_campaign else "")
            
            campaign_type = st.selectbox("üìã Campaign Type", [
                "Product Launch", "Brand Awareness", "Seasonal Campaign", "Customer Retention",
                "Lead Generation", "Event Promotion", "Sales Campaign", "Newsletter Campaign"
            ])
            
            target_audience = st.text_area("üë• Target Audience", 
                placeholder="Describe demographics, interests, pain points...")
            
            duration = st.text_input("üìÖ Campaign Duration", placeholder="e.g., 4 weeks, 2 months")
        
        with col2:
            channels = st.multiselect("üì¢ Marketing Channels", [
                "Email Marketing", "Social Media", "Google Ads", "Facebook Ads", 
                "Content Marketing", "Influencer Marketing", "TV/Radio", "Print Media"
            ])
            
            location = st.selectbox("üåç Target Country", COUNTRIES)
            city_state = st.text_input("üèôÔ∏è City/State", placeholder="e.g., New York, NY")
            customer_segment = st.selectbox("üíº Customer Segment", 
                ["Mass Market", "Premium", "Niche", "Enterprise", "SMB"])
        
        # Budget and Currency
        budget_col1, budget_col2 = st.columns(2)
        with budget_col1:
            budget = st.text_input("üí∞ Budget Amount", placeholder="e.g., 50000")
        with budget_col2:
            currency = st.selectbox("üí± Currency", CURRENCIES)
        
        product_description = st.text_area("üì¶ Product/Service Description",
            placeholder="Describe what you're promoting...")
        
        # Buttons
        col1, col2 = st.columns(2)
        with col1:
            generate_campaign = st.form_submit_button("üöÄ Generate Campaign Strategy", use_container_width=True)
        with col2:
            generate_image = st.form_submit_button("üé® Generate Campaign Image", use_container_width=True)
    
    # Handle campaign generation
    if generate_campaign and company_name and campaign_type:
        campaign_data = {
            'company_name': company_name,
            'campaign_type': campaign_type,
            'target_audience': target_audience,
            'duration': duration,
            'channels': channels,
            'location': location,
            'city_state': city_state,
            'customer_segment': customer_segment,
            'budget': budget,
            'currency': currency,
            'product_description': product_description
        }
        
        with st.spinner("ü§ñ Groq AI is generating your comprehensive campaign strategy..."):
            generator = GroqAIGenerator()
            blueprint = generator.generate_campaign_blueprint(campaign_data)
            
            # Store in session state
            st.session_state.current_campaign = campaign_data
            st.session_state.campaign_blueprint = blueprint
            
            st.success("‚ú® Campaign strategy generated successfully!")
            st.balloons()
    
    # Handle image generation
    if generate_image and st.session_state.current_campaign:
        campaign_desc = f"{st.session_state.current_campaign['company_name']} {st.session_state.current_campaign['campaign_type']}"
        image_gen = GeminiImageGenerator()
        image_gen.generate_campaign_image(campaign_desc, "professional")
    
    # Display existing campaign
    if st.session_state.campaign_blueprint:
        st.markdown("---")
        st.markdown("## üìã Your AI-Generated Campaign Strategy")
        st.markdown(st.session_state.campaign_blueprint)
        
        # Action buttons
        col1, col2, col3 = st.columns(3)
        with col1:
            if st.button("üìß Create Email Campaign", use_container_width=True, key="goto_email"):
                st.session_state.current_page = "Email Marketing"
                st.rerun()
        with col2:
            if st.button("üìä View Analytics", use_container_width=True, key="goto_analytics"):
                st.session_state.current_page = "Analytics & Reports"
                st.rerun()
        with col3:
            if st.session_state.current_campaign:
                st.download_button("üìÑ Download Strategy", 
                    data=st.session_state.campaign_blueprint,
                    file_name=f"{st.session_state.current_campaign['company_name']}_strategy.md",
                    mime="text/markdown",
                    use_container_width=True)

def show_email_marketing():
    st.header("üìß AI Email Marketing Center")
    
    # Show active campaign
    if st.session_state.current_campaign:
        st.success(f"üéØ Active: **{st.session_state.current_campaign['company_name']}** - {st.session_state.current_campaign['campaign_type']}")
    else:
        st.info("üí° Create a campaign first for AI-generated content")
    
    # Email content generation
    st.subheader("üé® Generate Personalized Email Content with Groq AI")
    
    with st.form("email_content_form"):
        template_col1, template_col2 = st.columns(2)
        
        with template_col1:
            email_type = st.selectbox("üìß Email Type", [
                "Welcome Email", "Product Announcement", "Promotional Offer", 
                "Newsletter", "Follow-up Email", "Event Invitation", "Customer Survey"
            ])
            tone = st.selectbox("üé≠ Tone", ["Professional", "Friendly", "Casual", "Urgent", "Formal"])
        
        with template_col2:
            content_format = st.radio("üìù Format", ["HTML Template", "Plain Text"])
            
        generate_content = st.form_submit_button("üöÄ Generate AI Email Content", use_container_width=True)
    
    if generate_content:
        if st.session_state.current_campaign:
            with st.spinner("ü§ñ Groq AI is crafting your personalized email content..."):
                generator = GroqAIGenerator()
                content = generator.generate_personalized_email_content(
                    st.session_state.current_campaign, 
                    email_type, 
                    tone, 
                    content_format
                )
                
                if content_format == "HTML Template":
                    st.session_state.email_template = content
                else:
                    st.session_state.plain_text_template = content
                
                st.success("‚ú® AI email content generated!")
        else:
            st.warning("‚ö†Ô∏è Please create a campaign first")
    
    # Template editor
    if st.session_state.email_template or st.session_state.plain_text_template:
        st.markdown("---")
        st.subheader("üìù Edit Email Content")
        
        # Choose template type
        if st.session_state.email_template and st.session_state.plain_text_template:
            edit_choice = st.radio("Edit:", ["HTML Template", "Plain Text"], key="edit_choice")
            current_template = st.session_state.email_template if edit_choice == "HTML Template" else st.session_state.plain_text_template
        elif st.session_state.email_template:
            current_template = st.session_state.email_template
            edit_choice = "HTML Template"
        else:
            current_template = st.session_state.plain_text_template
            edit_choice = "Plain Text"
        
        # Editor
        edited_content = st.text_area("Email Content:", 
            value=current_template, 
            height=400,
            help="Use {{first_name}}, {{name}}, and {{email}} for personalization")
        
        # Update session state
        if edit_choice == "HTML Template":
            st.session_state.email_template = edited_content
        else:
            st.session_state.plain_text_template = edited_content
        
        # Preview HTML
        if edit_choice == "HTML Template" and st.button("üëÄ Preview Email", key="preview_btn"):
            personalizer = EmailPersonalizer()
            preview = personalizer.personalize_template(edited_content, "John Smith", "john@example.com")
            st.components.v1.html(preview, height=500, scrolling=True)
    
    st.markdown("---")
    
    # Contact upload
    st.subheader("üë• Upload Email Contacts")
    
    uploaded_file = st.file_uploader("Upload CSV/Excel file with emails", 
        type=['csv', 'xlsx'], key="contact_upload")
    
    if uploaded_file:
        processor = FileProcessor()
        contacts = processor.process_file(uploaded_file)
        
        if contacts is not None:
            st.session_state.email_contacts = contacts
            
            # Show editable contacts
            st.subheader("üìã Review & Edit Contacts")
            edited_contacts = st.data_editor(
                contacts,
                column_config={
                    "email": st.column_config.TextColumn("üìß Email Address"),
                    "name": st.column_config.TextColumn("üë§ Full Name")
                },
                num_rows="dynamic",
                use_container_width=True,
                key="contact_editor"
            )
            st.session_state.email_contacts = edited_contacts
    
    # Email campaign launch - COMPLETELY FIXED
    if (st.session_state.email_contacts is not None and 
        (st.session_state.email_template or st.session_state.plain_text_template)):
        
        st.markdown("---")
        st.subheader("üöÄ Launch Email Campaign")
        
        df = st.session_state.email_contacts
        
        # Campaign overview
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("üë• Total Contacts", len(df))
        with col2:
            domains = df['email'].str.split('@').str[1].nunique()
            st.metric("üè¢ Email Domains", domains)
        with col3:
            st.metric("üìß Template Status", "‚úÖ Ready")
        
        # Campaign configuration
        config_col1, config_col2 = st.columns(2)
        
        with config_col1:
            subject = st.text_input("üìß Email Subject Line", 
                value="Personalized message for {{first_name}}",
                help="Use {{first_name}} and {{name}} for personalization")
            
            test_email = st.text_input("üß™ Test Email Address", 
                placeholder="your@email.com")
        
        with config_col2:
            # Choose email format
            if st.session_state.email_template and st.session_state.plain_text_template:
                send_format = st.radio("üìù Email Format:", ["HTML Email", "Plain Text Email"])
                template_to_use = st.session_state.email_template if send_format == "HTML Email" else st.session_state.plain_text_template
                is_html = send_format == "HTML Email"
            elif st.session_state.email_template:
                template_to_use = st.session_state.email_template
                is_html = True
                st.info("‚úÖ HTML template ready")
            else:
                template_to_use = st.session_state.plain_text_template
                is_html = False
                st.info("‚úÖ Plain text template ready")
        
        # Test email functionality
        if test_email:
            if st.button("üß™ Send Test Email", key="test_email_btn"):
                email_handler = EmailHandler()
                personalizer = EmailPersonalizer()
                
                test_content = personalizer.personalize_template(template_to_use, "Test User", test_email)
                test_subject = personalizer.personalize_template(subject, "Test User", test_email)
                
                with st.spinner("Sending test email..."):
                    success, error_msg = email_handler.send_single_email(test_email, test_subject, test_content, is_html)
                
                if success:
                    st.success("‚úÖ Test email sent successfully!")
                else:
                    st.error(f"‚ùå Test email failed: {error_msg}")
        
        # FIXED Launch campaign section
        st.markdown("### üéØ Launch Campaign")
        
        # Launch button
        if st.button("üöÄ LAUNCH PERSONALIZED EMAIL CAMPAIGN", 
                    type="primary", 
                    use_container_width=True, 
                    key="launch_campaign_btn"):
            
            # Validate configuration
            if not GMAIL_USER or not GMAIL_APP_PASSWORD:
                st.error("‚ùå Gmail configuration missing!")
                st.error("Please add these to your .env file:")
                st.code("""
GMAIL_USER=your_email@gmail.com
GMAIL_APP_PASSWORD=your_16_digit_app_password
                """)
                st.info("üí° Get your app password from Google Account Security settings")
                st.stop()
            
            # Set sending flag
            st.session_state.email_sending = True
            
            # Warning and confirmation
            st.warning(f"‚ö†Ô∏è About to send {len(df)} personalized emails. This cannot be undone!")
            
            # Confirmation button with unique key
            confirm_key = f"confirm_send_{datetime.now().timestamp()}"
            
            if st.button("‚úÖ CONFIRM & SEND ALL EMAILS", 
                        key=confirm_key, 
                        type="secondary"):
                
                st.info("üöÄ Launching personalized email campaign...")
                
                # Initialize components
                email_handler = EmailHandler()
                personalizer = EmailPersonalizer()
                
                # Send emails with the completely fixed function
                results = email_handler.send_bulk_emails_completely_fixed(
                    df, subject, template_to_use, personalizer, is_html
                )
                
                # Process results
                if not results.empty:
                    success_count = len(results[results['status'] == 'sent'])
                    failed_count = len(results[results['status'] == 'failed'])
                    invalid_count = len(results[results['status'] == 'invalid'])
                    success_rate = (success_count / len(results)) * 100
                    
                    st.markdown("### üéâ Campaign Results")
                    
                    # Results metrics
                    result_col1, result_col2, result_col3, result_col4 = st.columns(4)
                    
                    with result_col1:
                        st.metric("‚úÖ Successfully Sent", success_count)
                    with result_col2:
                        st.metric("‚ùå Failed", failed_count)
                    with result_col3:
                        st.metric("‚ö†Ô∏è Invalid Emails", invalid_count)
                    with result_col4:
                        st.metric("üìä Success Rate", f"{success_rate:.1f}%")
                    
                    # Store results for analytics
                    st.session_state.campaign_results = results
                    
                    # Success celebration
                    if success_count > 0:
                        st.balloons()
                        st.success(f"üéä Campaign completed! {success_count} emails sent successfully!")
                    
                    # Download results
                    csv = results.to_csv(index=False)
                    st.download_button("üì• Download Campaign Results", 
                        data=csv, 
                        file_name=f"email_campaign_results_{datetime.now().strftime('%Y%m%d_%H%M')}.csv",
                        mime="text/csv",
                        use_container_width=True)
                    
                    # Detailed results
                    with st.expander("üìã View Detailed Results"):
                        st.dataframe(results, use_container_width=True)
                
                # Reset sending flag
                st.session_state.email_sending = False
        
        # Show any generated images
        if st.session_state.generated_images:
            st.markdown("---")
            st.subheader("üé® Campaign Images")
            for i, img_data in enumerate(st.session_state.generated_images):
                if 'image' in img_data:
                    st.image(img_data['image'], caption=f"Campaign image {i+1}", use_column_width=True)

def show_analytics_reports():
    st.header("üìä Campaign Analytics & Reports")
    
    # Campaign-based analytics
    if st.session_state.current_campaign:
        st.subheader("üó∫Ô∏è Campaign Geographic Analysis")
        
        campaign = st.session_state.current_campaign
        location = campaign['location']
        
        if location in COUNTRIES_DATA:
            coords = COUNTRIES_DATA[location]['coords']
            
            # Create map
            map_data = pd.DataFrame({
                'lat': [coords[0]],
                'lon': [coords[1]], 
                'location': [location],
                'campaign': [campaign['campaign_type']],
                'company': [campaign['company_name']]
            })
            
            fig = px.scatter_mapbox(
                map_data,
                lat='lat',
                lon='lon',
                hover_name='location',
                hover_data={'campaign': True, 'company': True, 'lat': False, 'lon': False},
                color_discrete_sequence=['#00d4ff'],
                size_max=20,
                zoom=3,
                title=f"Campaign Target: {location}"
            )
            
            fig.update_layout(
                mapbox_style="carto-darkmatter",
                template="plotly_dark",
                height=500
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Campaign metrics
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("üéØ Campaign", campaign['campaign_type'])
            with col2:
                st.metric("üåç Location", location)
            with col3:
                st.metric("üí∞ Budget", f"{campaign.get('budget', 'TBD')} {campaign.get('currency', 'USD')}")
            with col4:
                st.metric("üìÖ Duration", campaign.get('duration', 'TBD'))
    
    # Email campaign results
    if st.session_state.campaign_results is not None:
        st.markdown("---")
        st.subheader("üìß Email Campaign Performance")
        
        results_df = st.session_state.campaign_results
        
        # Performance metrics
        total_sent = len(results_df[results_df['status'] == 'sent'])
        total_failed = len(results_df[results_df['status'] == 'failed'])
        total_invalid = len(results_df[results_df['status'] == 'invalid'])
        success_rate = (total_sent / len(results_df)) * 100
        
        perf_col1, perf_col2, perf_col3, perf_col4 = st.columns(4)
        
        with perf_col1:
            st.metric("üìß Total Emails", len(results_df))
        with perf_col2:
            st.metric("‚úÖ Delivered", total_sent)
        with perf_col3:
            st.metric("‚ùå Failed", total_failed)
        with perf_col4:
            st.metric("üìä Success Rate", f"{success_rate:.1f}%")
        
        # Results visualization
        status_counts = results_df['status'].value_counts()
        fig = px.pie(
            values=status_counts.values, 
            names=status_counts.index,
            title="Email Campaign Results Distribution",
            color_discrete_map={'sent': '#28a745', 'failed': '#dc3545', 'invalid': '#ffc107'}
        )
        fig.update_layout(template="plotly_dark")
        st.plotly_chart(fig, use_container_width=True)
        
        # Domain analysis
        if total_sent > 0:
            sent_emails = results_df[results_df['status'] == 'sent']
            sent_emails['domain'] = sent_emails['email'].str.split('@').str[1]
            domain_counts = sent_emails['domain'].value_counts().head(10)
            
            fig = px.bar(x=domain_counts.index, y=domain_counts.values,
                        title="Top Email Domains Reached",
                        color_discrete_sequence=['#00d4ff'])
            fig.update_layout(template="plotly_dark")
            st.plotly_chart(fig, use_container_width=True)
    
    else:
        st.info("""
        üìä **Analytics Dashboard**
        
        Create and launch email campaigns to see detailed analytics:
        - **Geographic Analysis**: Campaign targeting visualization
        - **Performance Metrics**: Email delivery and engagement rates
        - **Domain Analysis**: Recipient email domain breakdown
        - **Success Tracking**: Real-time campaign results
        """)

if __name__ == "__main__":
    main()
